# Хэширование и хэш-таблицы
Цель Map — сопоставить ключи с соответствующими им значениями. В частности, при использовании Map программист ожидает эффективных реализаций методов `get()` и `contains()`.

Если бы Map реализовалась через Unsorted Array (включая реализацию на основе ArrayList), Unsorted Linked List и Sorted Linked List, то при использовании методов `get()` и `contains()` скорость выполнения была бы `O(N)` , что в данном случае не самое эффективное. 
При использовании Sorted Array или балансированного бинарного дерева поиска, методы `get()` и `contains()` имели бы скорость выполнения `O(log2N)`, что лучше, но всё ещё недостаточно. 

> Рассмотрим пример, где имеются целые числа от 0 до 100, которые были сопоставлены с их описанием в виде слов. 
>
> [![](./images/MapExample.png)](./images/MapExample.png) 
>
> В данном примере вызывая `map.contains("91")` при использовани кода на основе ArrayList, программа просматривает первые 92 ячейки массива, прежде чем найти совпадение и вернуть true. Это будет занимать `O(N)`. Даже если бы мы выбрали для нашей Map реализацию на основе отсортированного массива, которая может использовать двоичный поиск, для поиска потребуется семь сравнений (`O(log2N)`), прежде чем найти нужный ключ. 
>
> Однако можно заметить, что можно было бы просто прочитать ввод пользователя как целое число и использовать это целое число в качестве индекса в базовом массиве (значение, связанное с 91, находится в позиции массива 91). Это будет `O(1)` — поиск записи за постоянное время.
>
> Это может пригодится в дальнейшем.

#### Представленный ниже подход называется **хешированием**, а базовая структура данных — массив, содержащий записи, — называется **хеш-таблицей**.

> Рассмотрим более прагматичный пример: список сотрудников довольно небольшой компании. Для начала мы рассмотрим компанию со 100 сотрудниками, каждый из которых имеет идентификационный номер в диапазоне от 0 до 99. Мы хотим получить доступ к информации о сотрудниках по ключу `idNum`. Если мы сохраним записи в хеш-таблице, индексированной от 0 до 99, мы сможем напрямую получить доступ к информации о любом сотруднике через индекс массива, как обсуждалось в примере с числами выше. Между ключами входа и индексами массива существует взаимно однозначное соответствие; по сути, индекс массива действует как ключ каждой записи.
>
> На практике эту идеальную связь между значением ключа и расположением записи не так-то легко установить или поддерживать. 
> 
> Поэтому рассмотрим аналогичную небольшую компанию со 100 сотрудниками, но эта компания использует пятизначные идентификационные номера для идентификации сотрудников. Если мы используем 5-значный идентификационный номер в качестве ключа, то диапазон значений ключа будет [00000; 99999]. В таком случае кажется расточительным создавать хеш-таблицу из 100 000 записей, из которых нужны только 100, просто чтобы убедиться, что запись каждого сотрудника находится в совершенно уникальном и предсказуемом месте.
> 
> Что, если мы ограничим размер хэш-таблицы тем размером, который нам действительно нужен (массив из 100 записей) и будем использовать только две последние цифры ключа для идентификации каждого сотрудника? 
> 
> Например, запись о сотруднике 53374 хранится в списке сотрудников[74], а запись о сотруднике 81235 — в списке сотрудников[35]. Записи располагаются в хеш-таблице в зависимости от значения ключа:
> 
> `location = (idNum % 100);`
> 
> Ключ `idNum` делится на 100, а остаток используется в качестве индекса в хеш-таблице записей о сотрудниках, как показано на рисунке. \
> [![](./images/CompressionFunctionExample.png)](./images/CompressionFunctionExample.png)  
>
> Эта функция предполагает, что хеш-таблица проиндексирована от 0 до 99 (MAX_ENTRIES = 100). В общем случае, учитывая целочисленный ключ, например `idNum`, и размер массива хранения, например `MAX_ENTRIES`, мы можем
связать местоположение хэш-таблицы с ключом, используя оператор:
> 
> `location = (idNum % MAX_ENTRIES);`
>
Используемая в данном примере функция $f(idNum) = idNum \% MAX\_ENTRIES$ называется ***функцией сжатия (Compression function)***, поскольку она «сжимает» более широкую область чисел [0; idNum], представляющую ключи, в меньший диапазон чисел [0; MAX_ENTRIES - 1], которые представляют индексы хеш-таблицы. Конечно, ключи не всегда будут целыми — в данном контексте предполагается, что так оно и есть, и важный вопрос о нецелых ключах будет рассмотрен далее.

Функция сжатия имеет два применения. Сначала он используется для определения места в хэш-таблице для хранения записи. Второе использование функции сжатия — определить, где искать запись. Если запрашивается информация, соответствующая idNum 65606, метод поиска использует 65606 % 100 = 06 в качестве индекса в хеш-таблице для получения информации.

## Коллизии
Можно заметить, что данный подход не гарантирует уникальность расположения каждого ключа в массиве. Например, уникальные идентификационные номера 01234 и 91234 «сжимаются» в одно и то же место: 34. Это называется ***коллизией***. Проблема минимизации таких коллизий является самой большой проблемой при разработке хорошей системы хеширования.


Предполагая, что происходят некоторые коллизии, где следует хранить записи, которые их вызывают? Ниже будет краткое описание нескольких популярных алгоритмов обработки коллизий. Какая бы схема ни использовалась для поиска места для хранения записи, ее также необходимо будет использовать при попытке найти запись. Выбор алгоритма обработки коллизий также влияет на варианты удаления записей.

В данном рассмотрении  алгоритмов разрешения коллизий будет предполагатся использование информации о массиве для хранения информации и location переменной int для указания слота массива/хеш-таблицы.

### Линейное зондирование (Linear probing)
Простая схема разрешения коллизий — сохранить конфликтующую запись в следующей доступной ячейке. Этот метод известен как линейное зондирование.

> Например, нужно добавить запись о сотруднике с идентификационным номером ключа 77003. 
> 
> Функция сжатия возвращает 03. Значит запись должны положить в слот [03]. Но в этом слоте хеш-таблицы уже есть запись, запись для сотрудника 50003. 
> 
> Индекс увеличивается до 04, и проверяется следующий слот хэш-таблицы. Поскольку слот с индексом [04] также используется, индекс снова увеличивается. На этот раз обнаруживается пустой слот, поэтому новая запись сохраняется в ячейку с индексом [05].
>
> [![](./images/LinearProbingExample01.png)](./images/LinearProbingExample01.png)  

Cоответсвенно, каждый раз, когда ячейка таблицы по индексу, высчитанному через функцию сжатия, будет занята, индекс будет увеличиваться на 1.

Хеш-таблицу можно рассматривать как циклическую структуру, поэтому поиск пустого слота можно продолжить с начала таблицы. Этот подход аналогичен очереди на основе кольцевого массива.

Для выолнения **поиска записи**, с помощью операций `get()` и `contains()`, применяется тот же алгоритм. Сначала вычисляется функция сжатия по искомуму ключу, берется запись из таблицы и искомый ключ сравнивается с ключом записи из таблицы. 

В случае, если **ключи не свопадают**, используется алгоритм линейного зондирования, начиная со следующей ячейки таблицы, и полученный индекс ячейки увеличивается на 1.

Поиск продолжается до тех пор, пока не будет найдена соответствующая запись (успешный поиск) или null-запись (неудачный поиск).

Но если у нас имеется заполненная хеш-таблица и происходит поиск записи, которая не содержится в данной хеш-таблице, то код будет постоянно циклически повторяться, и поиск ничего не даст. 

Решение данной проблемы: сохранить исходный индекс поиска, возвращенный функцией сжатия, а затем прекратить поиск, если текущий индекс совпадет с сохраненным. На практике большинство схем хеширования увеличивают размер базового массива, если их коэффициент загрузки (процент используемых слотов массива) превышает заданный порог. В этом случае массив никогда не будет полным, и нам не придется беспокоиться о бесконечном цикле.

### Квадратичное зондирование (Quadratic Probing)
Одна из проблем линейного зондирования заключается в том, что оно приводит к ситуации, называемой кластеризацией.

Предположим, что ключи в конечном итоге распределяются случайным образом, что приводит к равномерному распределению используемых индексов по всему диапазону индексов хеш-таблицы. 

Первоначально записи добавляются по всей хеш-таблице, при этом вероятность заполнения каждого слота равна. Со временем, после разрешения ряда коллизий, распределение записей в хеш-таблице становится все менее равномерным. Записи имеют тенденцию группироваться вместе, поскольку несколько ключей начинают конкурировать за одно место. Это явление происходит даже при хорошем случайном распределении ключей.

> В слот хеш-таблицы [08] будет вставлена только запись, ключ которой дает значение сжатия 08. Однако любые записи с ключами, которые создают значение сжатия 03, 04, 05, 06 или 07, будут вставлены в слот хэш-таблицы [07]. То есть вероятность заполнения слота хеш-таблицы [07] в пять раз выше, чем слота хеш-таблицы [08]. Как только происходит столкновение или две записи в противном случае оказываются рядом друг с другом в хеш-таблице, вероятность того, что две из них, рассматриваемые как единое целое, «попадут», в два раза выше, чем любой другой слот в хеш-таблице. И этот вероятностный эффект усиливается по мере добавления новых записей, что приводит к образованию кластеров использованных местоположений по всей хеш-таблице. Кластеризация приводит к нестабильной эффективности операций сбора и делает использование порога загрузки для базового массива еще более важным, когда используется линейное зондирование.

Кластеризация — это побочный эффект линейного зондирования. Другой подход к разрешению коллизий, называемый квадратичным зондированием, уменьшает эффект кластера. При линейном зондировании код добавляет постоянное значение 1 к ячейке до тех пор, пока не найдет открытый слот хеш-таблицы. При квадратичном зондировании добавленная стоимость на каждом этапе зависит от того, сколько мест уже
был проверен. В первый раз, когда он ищет новое местоположение, он добавляет 1 к исходному местоположению, во второй раз он добавляет 4 к исходному местоположению, в третий раз он добавляет 9 к исходному местоположению и так далее — в i-й раз он добавляет $i^2$.

Поскольку мы прыгаем вперед на все больше и больше мест, каждый раз, когда «зонду» не удается найти доступный слот, эффект кластеризации снижается. Пример, показанный на рис. 8.9, наглядно демонстрирует разницу. Однако мы должны быть осторожны с этим подходом, потому что мы можем оказаться в бесконечном цикле проверок, даже если в хеш-таблице есть пустые ячейки. Мы можем решить эту проблему, отслеживая, сколько попыток зондирования было предпринято, и если счетчик достигает размера хеш-таблицы, прекращая поиск.

Еще лучше, мы можем поддерживать порог загрузки ниже 50% и использовать размер хэш-таблицы, который является простым числом. Теоретики доказали, что ситуация вырожденного бесконечного цикла не возникнет, пока мы соблюдаем эти условия.

### Buckets	and	Chaining
Другая, возможно, лучшая альтернатива для обработки коллизий — разрешить записям находиться в одном и том же месте. 

Один из подходов позволяет каждому вычисленному местоположению содержать ячейки для нескольких записей, а не только для одной записи. Каждое из этих мест с несколькими значениями называется *бакетом*.

>На рис. 8.10 показан пример сегментов, каждый из которых может содержать по три записи. Используя этот подход, мы можем разрешить коллизии создавать повторяющиеся записи в одном и том же месте до определенного момента. Когда *бакет* наполнится, нам придется снова заняться проблемой определения нового местоположения.
>
>Другое решение, позволяющее избежать этой проблемы, — хранить связанный список записей в каждом месте. Каждая ячейка хеш-таблицы имеет доступ к *цепочке* записей. Рисунок 8.11 иллюстрирует этот подход. Запись в хеш-таблице в каждом месте содержит ссылку на связанный список записей.
Для поиска данной записи мы сначала применяем функцию сжатия к ключу, а затем ищем запись в указанной цепочке. Поиск не исключается, но ограничивается записями, которые фактически имеют одинаковое значение сжатия. Напротив, при линейном зондировании нам, возможно, придется искать множество дополнительных записей, если слоты, следующие за местоположением, заполнены записями из столкновений в других местоположениях.

## Хэш-функция
Хэш-функция — это функция, получающие на входе данные, обычно строку, и возвращающие число (хэш-код). При многократном вызове хэш-функции с одинаковыми входными данными она всегда будет возвращать одно и то же число, и возвращаемое число всегда будет находиться в гарантированном интервале.

Чтобы получить максимальную выгоду от системы хеширования, описанной в предыдущем разделе, нам необходимо, чтобы возможные местоположения, используемые в базовом массиве, были как можно более разбросаны. На этот разброс влияют два фактора: размер базового массива и набор целочисленных значений, представленных функции сжатия. Сначала будет раздел о размерном факторе, а затем — создание хорошего набора целочисленных значений.

### Размер массива
Один из способов минимизировать коллизии с хэш-функцией — использовать массив, имеющий значительно больше места, чем фактически необходимо для количества записей, тем самым увеличивая диапазон функции сжатия. Это дополнительное пространство снижает негативное воздействие коллизий, предоставляя широкий диапазон для значений.



Доп. информация: 
* https://github.com/rurban/smhasher: этот репозиторий — золотой стандарт тестирования качества хэш-функций. Он проводит кучу тестов, выполняя сравнение с большим количеством хэш-функций, и представляет результаты в виде большой таблицы. Может быть сложно понять, для чего нужны все эти тесты, но это самая современная система для тестирования хэш-функций.